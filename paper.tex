%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[10pt, sigplan]{acmart}
%%\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,10pt,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,10pt,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan,10pt]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
%\acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
%\acmYear{2017}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
%\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{ifthen}
%\input{macros.tex}

\usepackage{xcolor}
\newcommand{\sd}[1]{\color{red}\fbox{\bfseries\sffamily\scriptsize Stef:}{\sf\small$\blacktriangleright$\textit{#1}$\blacktriangleleft$}\color{black}}
\newcommand{\sk}[1]{\color{blue}\fbox{\bfseries\sffamily\scriptsize Sophie:}{\sf\small$\blacktriangleright$\textit{#1}$\blacktriangleleft$}\color{black}}
\newcommand{\cba}[1]{\color{purple}\fbox{\bfseries\sffamily\scriptsize Clement:}{\sf\small$\blacktriangleright$\textit{#1}$\blacktriangleleft$}\color{black}}


\begin{document}

%% Title information
\title[Assessing primitives performance on multi-stage execution]{Assessing primitives performance\\ on multi-stage execution}       

%% Author with single affiliation.
\author{Sophie Kaleba}
                                        %% can be repeated if necessary
\affiliation{
  %\position{Position1}
  \department{RMoD}              %% \department is recommended
  \institution{Inria}            %% \institution is required
 % \streetaddress{Street1 Address1}
  \city{Lille}
  %\state{France}
  %\postcode{Post-Code1}
  \country{France}                    %% \country is recommended
}
\email{sophie.kaleba@etudiant.univ-lille1.fr}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Cl\'ement B\'era}
\affiliation{
  % \position{}
	\department{Software Languages Lab}              %% \department is recommended
	\institution{Vrije Universiteit Brussel}            %% \institution is required
	\city{Brussel}
  % \state{}
  % \postcode{}
	\country{Belgium}                    %% \country is recommended
}
\email{clement.bera@vub.ac.be}          %% \email is recommended

%% Author with two affiliations and emails.
\author{St\'ephane Ducasse}
\affiliation{
 % \position{Position2b}
  \department{RMoD}             %% \department is recommended
  \institution{Inria}           %% \institution is required
  %\streetaddress{Street3b Address2b}
  \city{Lille}
  %\state{State2b}
  %\postcode{Post-Code2b}
  \country{France}                   %% \country is recommended
}
\email{stephane.ducasse@inria.fr}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}

Virtual machines, besides the interpreter and just-in-time compiler optimization facilities, also include a set of primitive operations that the client language can use. Some of these are essential and cannot be performed in any other way. Others are optional, they can be expressed in the client language but are often implemented in the virtual machine to improve performance when the just-in-time compiler is unable to do so (start-up performance, speculative optimizations not implemented or not mature enough, etc.).

In a hybrid runtime, where code is executed by an interpreter and a just-in-time compiler, the implementor can choose to implement optional primitives in the client language, in the virtual machine implementation language (typically C or C++) or on top of the just-in-time compiler back-end. We implemented the String comparison optional primitive in each case. This paper describes the different implementations and compares the execution time in Cog, a Smalltalk virtual machine. 

The paper shows that the implementation with the most reliable and high performance is also the most complex and difficult to implement. Since hundreds of optional primitives can be available, the virtual machine implementor has to carefully choose how to implement each of them to balance between maintenance cost and high performance.

\end{abstract}

%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
%\begin{CCSXML}
%<ccs2012>
%<concept>
%<concept_id>10011007.10011006.10011008</concept_id>
%<concept_desc>Software and its engineering~General programming languages</concept_desc>
%<concept_significance>500</concept_significance>
%</concept>
%<concept>
%<concept_id>10003456.10003457.10003521.10003525</concept_id>
%<concept_desc>Social and professional topics~History of programming languages</concept_desc>
%<concept_significance>300</concept_significance>
%</concept>
%</ccs2012>
%\end{CCSXML}

%\ccsdesc[500]{Software and its engineering~General programming languages}
%\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{Just-in-Time compiler, Primitive, Virtual machine, Managed runtime}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}
\label{sec:intro}

High level object oriented programming languages are often implemented on top of a virtual machine (VM). As VMs has become more popular, different techniques have been set-up using Just-In-Time (JIT) compilation to improve the overall performance of the runtime such as method JITs \cite{ursPHD} which usually compile methods to native code and tracing JITs \cite{Dynamo, PyPyTracing} which usually compile linear traces of execution into native code. 

On top of its virtual machine, the client language can use a set of \emph{primitives}~\footnote{We use in the paper the Smalltalk terminology (primitive) as this is the programming language used for our evaluation. Some other programming languages, such as Javascript, prefer to use the term built-in instead of primitive.}, which are performed directly by the interpreter rather than by evaluating expressions in a method. We distinguish two kinds of primitives:
\begin{itemize}
	\item \emph{Essential primitives} cannot be performed in any other way. A high-level object oriented language without primitives can move values from one variable to another, but cannot add two integers together. Many arithmetic and comparison operations between numbers are primitives. Some primitives allow to communicate with I/O devices such as the disk, the display and the keyboard. 	\item \emph{Optional primitives} exist only to make the system run faster. They can be implemented in the client language directly, making its implementation as a primitive optional, but they are implemented in the VM to improve performance.
\end{itemize}

The implementation of an optional primitive in the VM rather than the client language improves performance but also often increases the implementation engineering cost. For example, accessing objects in the VM usually requires some understanding of the memory layout or implementation details, which are not needed in the client language. 

For this reason, some virtual machine implementors attempted to remove most or all optional primitives. Their goal was to improve the execution of the client language with a JIT performing speculative optimizations \cite{ursPHD} for the execution of the optional primitives implemented in the client language to be as fast as the performance of the same primitives written in the VM. Self \cite{ursPHD} and Strongtalk \cite{Strongtalk} were to first to try this approach. Early versions of the Javascript engine V8 \cite{V8} also implemented most of the primitives, including for example Array operations, in Javascript itself. However, without optional primitives implemented in the VM, several problems rise:
\begin{itemize}
	\item High performance relies on a JIT with speculative optimizations, which is hard to implement, maintain and evolve,
	\item The performance of the code not yet optimized is much worse than the peak performance code,
	\item Even mature JIT fail to optimize some narrow cases, where the performance is drastically slower.
\end{itemize}
Overall, this approach requires high engineering time to get a mature optimizing JIT with speculative optimizations and even then, it leads in practice to unreliable performance. 

VMs are traditionally implemented in a low-level language such as C or C++. To balance between memory footprint, start-up performance and peak performance, the execution of code is usually done through multiple execution tiers: the first few executions of a code snippets are done through an interpreter and the JIT compiles at runtime the frequently used code snippets for further executions to be performed quicker. This leads to annoying concerns. For example, let's say we implement a primitive in C. Frequently used portion of code calling that primitive are going to be compiled to native code by the JIT. This is problematic since the native code generated by the JIT is not directly compatible with native code generated by the C compiler: a call from one to another may require to edit the stack pointer and the frame pointer from the client stack to the C stack and to spill or move multiple registers. Switching between both can waste up to around a dozen native instructions. If the primitive is going to execute many instructions, the switch overhead might be negligible, but if the primitive executes only a few instructions, the overhead can be noticeable.

In the paper, we took the example of a string comparison optional primitive. The primitive compares two strings and answers if one string is greater, equal or lower than the other string. The exact specification are detailed in Section \ref{subsec:primSpec}. We implemented a first version in Smalltalk. We then implemented multiple version compiling through C compilers to native code, using different part of our VM infrastructure. Lastly, we implemented a version in the back-end of the JIT. Each time, we tried to write the code in the most efficient way possible. Then, we compared the execution time of all versions, showing that overall the most complex implementation is the fastest to execute.

Section \ref{sec:implContext} describes our implementation context, \emph{i.e.,} the execution model of the VM we used for our evaluation, how it executes primitives and the specification of our string comparison primitive. Section \ref{sec:implem} details the various implementations of the primitive we used for the evaluation. In Section \ref{sec:eval}, we evaluate the performance of the different implementations with different C compilers and string sizes. We also show the native code of the performance critical part of the primitive generated by each version and discuss it. Further sections compare our work to related works, discuss future work and conclude.

\section{Implementation context}
\label{sec:implContext}

Our evaluation is based on the Cog VM a Smalltalk virtual machine. The Cog VM is based on Dan Ingalls' Smalltalk VM \cite{BackToTheFuture} and have been enhanced with a JIT \cite{CogJIT} compiling one method or closure at a time to native code. Historically, the VM implemented a 32-bits adaptation of the Smalltalk-80 specifications \cite{blueBook}, but the Cog VM is now the default VM for multiple programming languages such as Pharo \cite{PharoByExample}, Squeak \cite{SqueakByExample} and Newspeak \cite{NewspeakOopsla}. 

Section \ref{sec:VMCompil} describes briefly the implementation languages and compilation process of the Cog VM. Section \ref{sec:VMexec} explains briefly the hybrid execution model with an interpreter and a JIT. In Section \ref{sec:primExec}, we detail how primitives are executed. Section \ref{subsec:primSpec} discusses the specifications of the string comparison primitive used for our evaluation.

\subsection{VM compilation}
\label{sec:VMCompil}

Similar to \cite{RPythonToolchain}

Impl langage. JIT.

Il faut expliquer le process de compilation de la VM. (Slang -> C, C-> ASM,

\begin{figure}[tb]
		\centering
		\includegraphics[width=0.6\linewidth]{figures/VMCompilation}
		\caption{VM compilation}
		\label{fig:VMCompilation}
\end{figure}


\subsection{VM execution}
\label{sec:VMexec}

exec hybrid interp 
 au runtime JIT ST->ASM)
 execution with C and St stack

Il faut que tu précises bien le coût de changement entre la pile St et la pile C et que tu expliques le probleme des primitives C courtes appelées depuis le code généré par le JIT. C'est important pour la suite. 

\subsection{Primitive execution}
\label{sec:primExec}


 Il faut definir primitive, primitive essentielle, primitive d'optimisation. Il faut expliquer brievement les primitives Smalltalk, comment elles sont activées, dans quelles cas le fall back code est appelé, que si elles fail c'est side-effect free. => Dans mon papier ISMM'15 il y a une explication section 4.2 le début de Primitive operations. dont tu peux t'inspirer, voir copier coller comme je suis auteur des 2.

primitive performance: VM without opt JIT, before reaching peak perf, or jit incorrectly optimizing specific part of code.


\subsection{String comparison primitive}
\label{subsec:primSpec}

Section \ref{subsec:context} explain why we changed it.

 Comme le coeur du papier est sur String prim, tu introduis la primitive sur laquelle tu vas travailler, dont la representation des strings, ses cas d'utilisation
 Short description of the String class (String, ByteString, WideString)?

\section{Different primitive implementations}
\label{sec:implem}
 
 \subsection{Context}
 \label{subsec:context}
 
 \cba{Move that to past section?}
 
 [Max 1/2 page, justifie 1,2,3 et non neg,0,pos]
 
We had SmartSyntax primitive.
Explain 1,2,3 results
Problem compatibility other languages
expect neg,0,pos

Wanting to improve performance

2 critical problems:
(1) changing the prim => changing all clients (VM compil from Pharo or Squeak different results)
(2) no support in SmartSyntax for read-only objects. [plugins but not String comparison]

Premiere tentative Eliot -> Slang plugin. Keep 1,2,3. Resoud Read-only / changing the prim problems.

Deuxieme tentative Slang internal, then Cog's RTL.
=> pour simplifier le RTL neg,0,pos etait mieux => minus instead of branches.
=> compat execution model, Slang internal neg,0, pos too.

 \subsection{Different implementation and execution}
 
- Pure Smalltalk: baseline
Smalltalk code on top of VM. Used as our baseline for benchmarks.
Write down the Smalltalk code here.
Expliquer to:do: over do: (to explain expresiveness) => core lib often use to:do: and not do:

- Smart Syntax Plugin
%= aString 	
%	self == aString ifTrue: [ ^true ].
%	aString isString ifFalse: [ ^false ].
%	self size = aString size ifFalse: [ ^false ].
%	1 to: self size do: [:i | (self at: i) = (aString at: i) ifFalse: [^false] ].
%	^ true
Restricted Smalltalk

written in Smalltalk with restrictions.
Compiled to C AOT into a plugin.

- Slang plugin 
Slang, but no access au fonctions de la VM drectement.
 interpreterProxy. (C compiler inlining, linking time ? cmacro ?)

- Slang pure

- Slang pure + Cog RTL

generate functions as machine code
partial implementation (frequent cases are implemented)
Sometimes, fallback to less-optimised version

 
 \subsection{Pros and cons}
 
  Can be changed like Smalltalk code (No C compilation whatsoever). Readability. Only impl without VM recompilation.

Baseline performance is not that great, jtted performance is good only with mature optimizing JIT we don't have.

Number of implementations: 1, 2 or 3: same implem for primitive in C and fall back code in Smalltalk, relatively easy to read/code.
recompilation. 
changing the prim => changing all clients (VM compil from Pharo or Squeak different results
Performance: cross file inlining not possible by default. (InterpreterProxy indirection)
Control on generated code => difference LLVM/GCC
 Pure C performance (no interpreter proxy).
 no C-St jump. Control over the outcome (reliable performance)
 costly jumps between Smalltalk and C runtime (trampolines), need to recompile vm sources, little control over outcome (c compilers 
 need to recompile vm sources (trampolines), code readability 
 
 \subsection{Comparison}


\cba{expliquer tableau comparatif}

Trade-off engineering time and performance.
- recompiler la VM ou pas (Plugin externes, code Smalltalk)
- complexite d'implem (comprehension Smalltalk, C, ASM)



%%%%%
% END OLD
%%%%%

\section{Evaluation}
\label{sec:eval}

All these versions of the primitives have been implemented. Compare performances

\subsection{Set-up}
Describe set-up:
GCC eval Ubuntu + machine spec
LLVM eval Mac OS X + machine spec.

\subsection{Micro-benchmarks}
Results on strings of different lengths (3, 10, 1000)

4 string length. (1er <=3, dernier > 1000) 
line 1: GCC
line 2: LLVM
String evaluation here.

\cba{Show ASM loops and discuss the differences
add appendix with full code}

\subsection{Macro-benchmarks}
JSON

\section{Related work}

Work on reducing the number of prim

RPython \cite{NoPrimTracing}

Self - Strongtalk -> tout en Smalltalk avec mature optimizing JIT. pb baseline perf, haut cout de maintenance implem pour l'adaptive optimizer \cite{Strongtalk, ursPHD}


	%\item Java: platform dependent
	 V8: interpreter compiled by JIT \cite{V8} Mention Ignition.
	optimised backend
	as if we were compiling slang using the JIT compiler (ahead of time)
	no more virtual call
	
 VisualWorks: baseline JIT but no interpreter => only 1 implement to write and maintain.


\cba{Ajoute le related work que tu as trouvé de ICOOOLPS avec le travail de Tim.}

\section{Future work and conclusion}
1. number of representations\\
2. common representation
\cba{Future work -> primitive processor dependent (i.e. SSE4 instrs), pros and cons and why you did not do it (ingeniering cost per back-end)}
\cba{Inlining in Sista + ref}

Conclusion: trade off expressiveness performance


%% Acknowledgments
%%\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
%  This material is based upon work supported by the
%  \grantsponsor{GS100000001}{National Science
%    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
%  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
%  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
%  conclusions or recommendations expressed in this material are those
%  of the author and do not necessarily reflect the views of the
%  National Science Foundation.
%\end{acks}


%% Bibliography
\bibliography{sista}


%% Appendix
\appendix
\section{Appendix}

\cba{Source code et generated C and ASM code for all versions}

Text of appendix \ldots

\end{document}
